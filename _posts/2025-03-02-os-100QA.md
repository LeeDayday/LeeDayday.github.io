---
title: "Operating Systems Interview Questions"

categories:
  - OS
tags: OS

date: 2025-03-02
last_modified_at: 2025-03-19
---

참고 자료
[Geeks for geeks](https://www.geeksforgeeks.org/operating-systems-interview-questions/)
### 0. 운영체제란?
- 사용자와 컴퓨터 시스템 간 GUI 역할 수행
	- 사용자와 컴퓨터 하드웨어 간 메모리,  processing, power, I/O 작업등의 자원을 관리
- 운영 체제는 컴퓨터에서 실행 중인 모든 process 를 관리
	- 각 process가 processor를 사용할 수 있도록 일정한 시간을 할당
	- 각 process가 필요한 memory나 disk 같은 다양한 자원 할당
- 대표적인 운영체제로는 Windows, MacOS, Linux, Android, ... 가 있음



### 1. Process, Process Table은 무엇인가?
- Process
	- 실행 중인 program의 instance
		- 웹 브라우저, 명령 프롬프트, ...
	- OS는 process가 필요한 자원들을 할당해준다.
		- memory, disk, ...
- Process Table
	- OS는 모든 process의 상태를 추적하기 위해 Process Table을 유지
	- 각 process가 사용 중인 자원과 process의 상태가 함께 기록

### 2. Process의 State
- NEW : 새롭게 생성된 프로세스가 가지는 상태입니다.
- READY (준비 상태): 
	- 준비 큐에서 운영체제에 의해 CPU에 로드되길 기다리는 상태입니다.
		- process 가 processor 사용 준비 갈 완료
		- OS가 processor를 할당해주기만을 기다려
- RUNNING (실행 상태): 
	- CPU에 로드되어 실행 중인 상태
		- 실행에 필요한 모든 자원 보유
		- OS로부터 processor를 사용할 권한 부여 받음
		- **한 번에 하나의 Process만 실행 상태가 될 수 있음**
- WAITING (대기 상태): 
	- I/O 이벤트가 발생했을 때 해당 이벤트가 처리되는 동안, 혹은 어떤 이벤트를 기다릴 때 Device queue 에서 대기하는 상태 입니다.
		- Process가 사용자 입력이나 Disk Access와 같은 외부 이벤트가 발생하기를 기다리는 상태
- TERMINATED : 프로세스가 종료되고 CPU 에서 제거되었을 때의 상태입니다.


### 3. Thread 란?
- Process 가 수행하는 작업의 실행 단위
- **Process 내부**에서 실행되는 단일 실행 흐름(Sequence Stream)
	- Process가 할당 받은 자원을 사용하여 작업을 수행
- 병렬 처리를 통해 어플리케이션 성능을 향상시키는데 널리 사용됨
	- ex) 웹 브라우저에서는 여러 개의 tab이 각각 다른 thread로 실행될 수 있음

### 4. Process 와 Thread의 차이
- Process
	- 실행 중인 program의 instance
	- 독립적인 실행 단위. 
	- 생성 시, **자체적인 메모리 공간**을 할당 받음 (코드 / 데이터 / 힙 / 스택) 
- Thread
	- Process 내에서 독립적으로 실행될 수 있는 가장 작은 명령어 단위 (process의 일부)
	- 한 Process 내 여러 Thread를 가질 수 있으며 
	  이 Thread들은 해당 thread의 자원을 일부 공유
		- 같은 주소 공간 (코드, 데이터, 힙 (운영 체제 자원 등)) 공유
			- *stack*은 고유 영역
		- 그래서 thread를 'lightweight process'라 부르기도 함
	- *각 thread는 개별적인 Program Counter (PC), Register, Stack space를 가지므로
	  같은 process 내에서도 독립적으로 실행될 수 있음*

### 5. Multithreading programming의 장점
- System의 반응성을 높이고 자원 공유를 가능하게 함
	- process 내부에 있는 thread는 *heap 영역을 공유*하기 때문에 thread끼리 공유 용이
	- 서로 공유하는 영역이 많기 때문에 CPU cache hit rate이 높아 
	  Multi processing 보다 context switching cost down⬇️
- Multiprocess architecture를 활용할 수 있도록 하며, 더 경제적이고 선호되는 방식


### 6. Thrashing 이란?
- 컴퓨터의 성능이 급격히 저하되거나 마비되는 현상
- 시스템이 실제 작업을 수행하는 시간보다 Page Fault를 처리하는 데 더 많은 시간을 소모할 때 발생
	- Page Fault - 가상 메모리의 장점을 활용하기 위해선 필수적이로 처리해야 함
- Page Fault 율이 급격히 증가하면 시스테 성능에 부정적인 영향을 미침
	- 더 많은 transaction 이 Paging Device에서 처리되어야 함
		- Paging Device의 queue가 길어짐
			- Page Fault의 서비스 시간 증가
				- 전체적인 성능 저하

### 7. Buffer 란?
- 두 장치 간 또는 장치와 application 간에 전송되는 데이터를 임시로 저장하는 메모리 영역 (**임시 저장소**)
- 주로 입출력 (I/O) 속도를 맞추거나 데이터 흐름을 조절하는데 사용
	- ex)
	  키보드를 빠르게 입력하면 OS가 이를 buffer에 저장한 후, 일정한 속도로 프로그램에 전달함
- Network 통신, 파일 입출력, 스트리밍에서도 데이터를 일정량 모아서 보내는 역할을 함


### 8. Virtual Memory란?
- 각 사용자가 연속적인 주소 공간을 가지고 있는것처럼 보이게 하는 기술
	- 각 주소는 0번지부터 시작하는 것처럼 보이지만,
	  실제로는 물리적 메모리 (RAM) 보다 훨씬 큰 크기를 가질 수 있음
- **디스크 공간을 이용하여 RAM을 확장**
	- 실행중인 process는 사용중인 memory가 RAM인지 Disk인지 신경쓸 필요 없이,
	  OS가 필요한 부분만 물리적 메모리로 로드하여 실행할 수 있도록 함
	- 가상 주소 공간을 작은 단위 (*page*) 로 나누어 필요할 때만 물리적인 메모리에 적재
		- 제한된 RAM보다 훨씬 효율적으로 사용 가능
---
- OS는 Program이 요청한 데이터나 코드가 RAM에 없는 경우 이를 감지하고
  Disk에서 해당 부분을 가져와 RAM에 적재  수행 (**Page Fault** 처리)
- **RAM을 효율적으로 관리: 필요할 때만 Disk에서 RAM으로 가져오기, 필요없으면 다시 Disk로**


### 9. OS의 주요 목적
- User와 Computer Hardware 간의 중개자 역할
	- User가 program을 편리하고 효율적으로 실행할 수 있는 환경을 제공하는 것
- OS는 Computer Hardware를 관리하는 Software
	- Hardware는 Computer system이 올바르게 작동하도록 적절한 제어 메커니즘을 제공,
	  user program이 system의 정상적인 작동을 방해하지 않도록 보호해야 함

### 10. Demand Paging 이란?
- OS에서 memory 사용을 최적화하고 시스템 성능을 향상시키기 위한 메모리 기법
	- Page Fault가 발생할 때마다 필요한 Page를 Memory에 로드하는 과정을 의미
		- *Page Fault*: 현재 실행중인 process가 필요로 하는 메모리 자원이 RAM에 없을 때 발생하는 이벤트
	- **Page를 미리 memory에 로드하지 않고, 필요할 때만 올려 사용. 필요하지 않은 page는 보조 기억 장치 (Disk)에 유지**

### 11. Kernel 이란?
- Operating Systems의 중심 구성 요소
- 컴퓨터와 하드웨어의 동작을 관리
	- Memory, CPU 시간의 운영 관리, ...
- Application과 하드웨어 수준에서 수행되는 데이터 처리 간의 다리 역할
- *IPC (Inter Process Communication, 프로세스간 통신)* 및 *System Calls (시스템 호출)* 을 사용하여 상호작용

### 12. 다양한 Scheduling Algorithms
- OS 는 CPU를 효율적으로 할당하기 위해 Scheduling Algorithms를 사용
- **FCFS (First-Come, First-Served) Scheduling**
	- 가장 먼저 도착한 process부터 처리
	- 가장 단순한 방식
	- *긴 프로세스가 먼저 실행되면 대기 시간이 길어지는 문제 발생* (Convoy Effect)
- **SJN (Shortest-Job-Next) Scheduling**
	- 실행시간이 가장 짧은 작업을 우선 실행
	- 평균 대기 시간이 짧아지는 장점
	- *실행 시간이 긴 프로세스가 계속 밀릴 수 있어 기아 현생 발생 가능* (Starvation)
- **Priority Scheduling**
	- 각 process에 우선순위 값을 부여하고, 높은 우선순위의 process를 먼저 실행
	- 긴급한 작업을 먼저 처리할 수 있음
	- *낮은 우선순위의 작업이 계속 밀릴 수 있음* (Starvation)
			- *Aging* 기법을 사용하여 Starvation 방지 가능
- **SRT (Shortest Remaining Time) Scheduling**
	- 현재 실행 중인 process와 비교하여, 실행 시간이 더 짧은 process가 도착하면 교체 (Preemptive)하여 실행
	- SJN 의 선점형 (Preemptive) 버전
	- 더 짧은 작업이 계속 들어오면 긴 작업이 계속 밀릴 수 있음 (Starvation)
- **RR (Round Robin) Scheduling**
	- 각 process에 동일한 시간 할당 (Time Quantum) 을 주고, 순환하며 실행
		- 모든 process가 일정한 시간마다 CPU를 할당받을 수 있음
		- *Time Quantum이 너무 크면  -> FCFS 같음
		  Time Quantum이 너무 작으면 -> Context Switching Overhead가 커짐*
- **Multiple-Level Queues Scheduling**
	- process를 여러 개의 Queue로 분류. 각 Queue에 다른 Scheduling Algorithms 적용
	- 실시간 process (높은 우선순위) 와 일반 사용자 process (낮은 우선순위)를 분리하여 관리 가능
		- 즉, Process의 특성에 따라 Queue 를 나누어 효율적으로 관리 가능
	- Queue 간 이동이 가능한 Multi-Level Feedback Queue 도 있다

### 13. Multi-Programming의 목적
- Organize Job (코드와 데이터를 정리)하여 CPU가 항상 실행할 작업을 갖도록 하여 **CPU 활용도** (CPU Utilization) 향상
- 주요 목적
	- 여러 개의 작업을 Main Memory (**RAM**)에 유지하는 것
	- 하나의 작업이 I/O 작업으로 인해 대기 상태에 들어가면, CPU가 다른 작업을 실행하도록 할당
		- CPU가 Idle State (유휴 상태) 로 들어가지 않도록

### 14. Time-Sharing System이란?
- Multi-Programming의 확장 개념
- CPU가 매운 빠른 속도로 작업을 전환 (Switching) 하여 여러 작업을 동시에 실행하는 것처럼 보이게 함
- Time-Sharing Operating System은 여러 사용자가 동시에 컴퓨터를 공유할 수 있도록 하며,
  각 사용자는 실행 중인 프로그램과 실시간으로 상호작용 가능

### 15. Computer System에 OS가 없다면?
- 자원 관리 부족 (Poor Resource Management)
	- CPU, Memory, Disk 등의 자원을 효율적으로 관리할 수 없음
	- 여러 프로그램을 동시에 실행하는 것이 어려워짐
- 사용자 인터페이스 부재 (Lack of User Interface)
	- GUI, CLI 제공 x
	- 사용자가 컴퓨터와 직접 상호작용할 수 없음
- 파일 시스템 없음 (No File System)
	- 파일을 저장/수정/삭제 하는 파일 시스템 제공 ㅌ
	- 데이터를 구조화하여 관리하는 것이 불가능해짐
- 네트워킹 기능 없음 (No Networking)
	- 인터넷 및 네트워크 연결 관리 불가
- 오류 처리 불가능 (Error Handling)
	- 프로그램 충돌, 메모리 오류 등 감지 + 복구 수행 불가
	- 에러를 처리할 수 없어 시스템이 쉽게 중단될 가능성이 높아짐

### 16. Multithreading Programming 의 장점
- Thread 는 lightweight process (경량 프로세스) 라고도 불림
- Multithreading Programming의 핵심 개념은 하나의 process를 여러 개의 thread로 나누어 병렬성을 달성하는 것
- 같은 process 내 thread들은 공유 메모리 공간에서 실행 됨

### 17. FCFS scheduling algorithm 이란?
-  Scheduling Algorithms
- 먼저 온 순서대로 (First Come First Served).
	- Ready Queue에 먼저 도착한 작업이 CPU를 할당받고 실행.
	  그 다음에 도착한 작업이 순차적으로 실행
- 비선점형 (Non-Preemptive)
	- 한 process가 CPU를 할당받으면 작업이 끝나거나 
	  I/O 작업을 수행할 때까지 CPU 계속 점유
- 한계
	- 실행 시간이 긴 작업이 먼저 할당되면, 그 뒤에 있는 짧은 작업들이 오랫동안 대기해야하는 문제 발생 가능

### 18. RR scheduling algorithm 이란?
- 각 process에게 **공평하게 CPU 시간을 할당**
	- 정해진 시간(Time Quantum) 동안 실행
	- 해당 시간이 지나면, 작업이 완료되지 않았더라고, CPU 를 다음 process로 넘기고
	남은 작업은 queue의 뒤로 이동
- 특징
	- FCFS에서 시간 할당 개념이 추가된 구조
	- 모든 process가 동일한 우선순위를 가짐
	- Time Slicing Scheduling 라고도 함
	- Starvation 발생 X (순환 방식이어서)

### 19. 다양한 RAID(level) 종류
- RAID(Redundant Array of Independent Disks, 중복 배열 독립 디스크)는 여러 개의 물리적 Disk Drive를 Operating Systems에서 하나의 논리적 장치로 인식하도록 구성하는 기술
- 빠른 Processor, 느린 Disk Drive 간의 성능 차이를 줄이는 역할
- 0 ~ 6까지의 level 존재
	- level이 높을 수록 보호 기능 강화 & 저장 효율 감소 경향


### 20. Bankers 알고리즘이란?
- 자원 할당 및 Deadlock 회피를 위한 Alg
- 모든 process가 필요로 하는 최대 자원량을 미리 파악한 뒤,
  그 자원들을 할당한다고 가정하여 시스템이 safe state에 있는지 시뮬
- 그 후, **안전성 검사 (s-state check)** 을 수행하여
  모든 process가 deadlock 없이 실행될 수 있는 경우에만 자원 할당 허용


### 21. 논리 주소 공간(Logical Address)와 물리 주소 공간(Physical Address)의 주요 차이점

| 구분 | 논리 주소 (Logical Address) | 물리 주소 (Physical Address) |
| --- | --- | --- |
| 기본 | CPU에 의해 생성 | 실제 메모리 장치에 에 위치 |
| 주소 공간 | CPU가 생성한 모든 주소의 집합 | 논리 주소와 매핑되는 실제 주소의 집합 |
| 가시성 | O | X |
| 생성 주체 | CPU | MMU (Memory Management Unit) |
| 사용자 접근 가능 여부 | 논리 주소를 사용해서 물리 주소에 접근 가능 | 물리 주소에 직접 접근 X |

- 논리 주소: process 가 보는 memory address (즉, 가상 주소)
- 물리 주소: 사용자가 직접 접근할 수 없으니, OS가 중간에 대신 처리해야 함
- => process 는 진짜 위치 (Physical Address) 를 신경 쓸 필요 없고, process가 아는 주소 (Logical Address) 만 사용 -> OS가 알아서 진짜 위치에 mapping