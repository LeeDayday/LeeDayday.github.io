---
title: "[Leetcode] Customers Who Bought All Products"

categories: [sql]
tags: [leetcode, sql]

date: 2025-06-30
last_modified_at: 2025-06-30
---
[문제 링크](https://leetcode.com/problems/customers-who-bought-all-products/description/?envType=study-plan-v2&envId=top-sql-50)

### 정답
```sql
SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (
    SELECT COUNT(product_key)
    FROM Product
)
```

#### ✅ Point
- customer 별 중복 없는 product_key 개수 세기
    - `GROUP BY customer_id` : 고객별로 묶기
    - `COUNT(DISTINCT product_key)`: 중복 없는 product_key rotn tprl
- 모든 제품을 샀는지 판단
    - `Product` table의 전체 제품 개수와 비교
- SubQuery는 상수와 비슷한 역할 수행
    - 대부분의 DB 엔진은 1번만 실행하고 Cache
- Order Of Execution
    - `From Customer` > `(SELECT COUNT(product_key) FROM PRODUCT)` > `GROUP BY` > `HAVING` > `SELECT`
    - Subquery는 Having 비교에 쓰이는 수간 그 전에 상수로 존재해야 함. (논리적으론 Subquery가 HAVING 보다 먼저 수행)
    - 다만, Optimizer가 내부에서 순서 최적화 수행
