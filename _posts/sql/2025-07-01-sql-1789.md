---
title: "[Leetcode] Primary Department for Each Employee"

categories: [sql]
tags: [leetcode, sql]

date: 2025-07-01
last_modified_at: 2025-07-01
---
[문제 링크](https://leetcode.com/problems/primary-department-for-each-employee/?envType=study-plan-v2&envId=top-sql-50)

### 정답
```sql
SELECT employee_id, department_id
FROM Employee
GROUP BY employee_id
HAVING COUNT(*) = 1

UNION

SELECT employee_id, department_id
FROM Employee
WHERE primary_flag = 'Y'
```

#### ✅ Point
- primary department 의 조건
    - 1. 한 직원(employee_id)이 여러 부서(department_id)에 속해있는 경우: primary_flag 가 Y인 부서가 primary department
    - 2. 한 직원(employee_id)이 한 부서(department_id)에만 속해있는 경우: primary_flag의 값과 상관 없이 해당 부서가 primary department

- 조건 1, 2를 만족하는 결과를 각각 SELECT로 구현한 뒤, UNION으로 합쳐 최종 결과 도출

### 다른 풀이
- Subquery & PARTITION BY
```sql
SELECT
    employee_id,
    department_id
FROM 
    (
        SELECT
            *,
            COUNT(employee_id) OVER(PARTITION BY employee_id) AS EmployeeCount
        FROM Employee
    ) EmployeePartition
WHERE
    EmployeeCount = 1
    OR primary_flag = 'Y';
```
- 조건 1, 2를 만족하는지 검증하기 위해 필요한 정보: 
    - employee_id 별 department_id의 개수: 
    - primary_flag 값
        - 이때, employee_id 로 GROUP BY를 한다면, 기존 row 별 primary_flag 값에 접근할 수 없음
        - 따라서 PARTITION BY를 통해 기존 primary_flag 을 유지하면서, 그룹화 수행
    - `COUNT(employee_id) OVER(PARTITION BY employee_id)`

- WHERE & SUBQUERY
```sql
SELECT
    employee_id,
    department_id
FROM 
    Employee
WHERE
    primary_flag = 'Y'
    OR employee_id IN (
        SELECT employee_id
        FROM Employee
        GROUP BY employee_id
        HAVING COUNT(employee_id) = 1
    );
```